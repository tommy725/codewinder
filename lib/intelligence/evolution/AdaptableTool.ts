import { Tool } from "langchain/tools";
import { Callbacks } from "langchain/dist/callbacks/manager";
import { BaseChatModel } from "langchain/chat_models";
import { LLMChain, PromptTemplate } from "langchain";
import { ChatOpenAI } from "langchain/chat_models/openai";
import { MemoryStore } from "@/lib/intelligence/memory/MemoryStore";

const DESCRIPTION = `
Can be used to write a javascript program which can complete any task. Improves over subsequent iterations.
This tool can write games and other types of display oriented programsd
`;

interface AdaptableToolInput {
    model: BaseChatModel;
    tools: Tool[];
    memory: MemoryStore;
    verbose?: boolean;
    callbacks?: Callbacks;
}

class AdaptableTool extends Tool {
    name = "adaptable-evolution";

    description = DESCRIPTION;

    memory: MemoryStore;
    model: BaseChatModel;
    tools: Tool[];

    constructor(options: AdaptableToolInput) {
        super(options.verbose, options.callbacks);

        this.memory = options.memory;
        this.model = options.model;
        this.tools = options.tools;
    }

    /** @ignore */
    async _call(input: string): Promise<string> {
        return await AdaptableTool.runAgent(this.callbacks, this.verbose, input);
    }

    static async runAgent(
        callbacks: Callbacks, verbose: boolean, input: string
    ): Promise<string> {
        const openAIApiKey = process.env.OPENAI_API_KEY;
        if (!Boolean(openAIApiKey)) {
            throw new Error('OpenAI API Key not found.');
        }

        const model = new ChatOpenAI({
            openAIApiKey,
            temperature: 0.8,
            streaming: Boolean(callbacks),
            callbacks
        });

        const CODE_PROMPT = `
You have access to a javascript interpreter.
Here is the request from the user: {input}
Respond with a javascript expression that evaluates to a string to meet the user's request.
The software program should always return a string.
        `;

        const codeChain = new LLMChain({
            llm: model,
            prompt: new PromptTemplate({ template: CODE_PROMPT, inputVariables: ["input"] }),
            callbacks,
            verbose
        });

        const completion = await codeChain.call({ input });
        console.log("Completion: ", completion);

        const execution = eval(completion.text);
        console.log("Execution: ", execution);

        const CRITIC_PROMPT = `
You are an AI which can critique the software programs.

Here is the request from the user: {input}
Here is the software program that was generated by another AI program earlier: {completion}

Evaluate whether the software program reasonable does what the user requested.

Here is the prompt that was used to guide the AI to generate this program: {guidance}

Rewrite the prompt to better guide the AI to generate a javascript program that better meets the a future request.
The new prompt should include {{input}} within the template as a placeholder for a future request.
Additionally, the prompt should be flexible to allow the AI to generate a variety of javascript programs.
The new prompt should guide future iterations of the AI to generate javascript programs that are general purpose.
        `;

        const cricitChain = new LLMChain({
            llm: model,
            prompt: new PromptTemplate({ template: CRITIC_PROMPT, inputVariables: ["input", "completion", "guidance"] }),
            callbacks,
            verbose
        });

        const critique = await cricitChain.call({ input, completion, guidance: CODE_PROMPT });
        console.log("Critique: ", critique.text);

        return execution;
    }
}
